import { NextRequest, NextResponse } from 'next/server';
import { jsPDF } from 'jspdf';

export async function POST(request: NextRequest) {
  try {
    const { content } = await request.json();

    if (!content || typeof content !== 'string') {
      return NextResponse.json(
        { error: 'No content provided' },
        { status: 400 }
      );
    }

    // Create PDF using jsPDF
    const doc = new jsPDF();
    
    // Set font and styling
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    
    // Add title
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text('Study Document', 20, 20);
    
    // Add generated date
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 20, 30);
    
    // Add horizontal line
    doc.line(20, 35, 190, 35);
    
    // Process content and add to PDF
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    
    // Clean up the content - remove markdown formatting and excessive whitespace
    const cleanContent = content
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
      .replace(/\*(.*?)\*/g, '$1') // Remove italic markdown
      .replace(/#{1,6}\s/g, '') // Remove markdown headers
      .replace(/\n\s*\n/g, '\n') // Remove multiple line breaks
      .trim();
    
    // Split content into lines and add to PDF with proper spacing
    const lines = cleanContent.split('\n');
    let yPosition = 45;
    const lineHeight = 6;
    const maxWidth = 170;
    const margin = 20;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      if (!line) {
        yPosition += lineHeight / 2; // Add small space for empty lines
        continue;
      }
      
      // Check if we need a new page
      if (yPosition > 270) {
        doc.addPage();
        yPosition = 20;
      }
      
      // Handle different types of content
      if (line.includes(':') && line.length < 100) {
        // Likely a heading or important point
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
      } else {
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(11);
      }
      
      // Split long lines
      const splitLines = doc.splitTextToSize(line, maxWidth);
      
      for (let j = 0; j < splitLines.length; j++) {
        if (yPosition > 270) {
          doc.addPage();
          yPosition = 20;
        }
        
        doc.text(splitLines[j], margin, yPosition);
        yPosition += lineHeight;
      }
      
      // Add extra space after headings
      if (line.includes(':') && line.length < 100) {
        yPosition += lineHeight / 2;
      }
    }
    
    // Add footer
    const pageCount = (doc as unknown as { internal: { getNumberOfPages: () => number } }).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text(`Generated by Study Mate - Page ${i} of ${pageCount}`, 20, 285);
    }
    
    // Generate PDF buffer
    const pdfBuffer = doc.output('arraybuffer');
    
    // Return PDF as response
    return new NextResponse(pdfBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': 'attachment; filename="study-document.pdf"',
        'Content-Length': pdfBuffer.byteLength.toString(),
      },
    });
    
  } catch (error) {
    console.error('Error generating PDF:', error);
    return NextResponse.json(
      { error: 'Failed to generate PDF' },
      { status: 500 }
    );
  }
}

export async function GET() {
  return NextResponse.json(
    { error: 'Method not allowed. Use POST with content to generate PDF.' },
    { status: 405 }
  );
} 